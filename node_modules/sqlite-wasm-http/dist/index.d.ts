import '#sqlite3-worker1-promiser.js';
import type * as SQLite from '#sqlite3-worker1-promiser.js';
import * as VFSHTTP from './vfs-http-types.js';
export * as VFSHTTP from './vfs-http-types.js';
export interface SQLiteOptions {
    http?: VFSHTTP.Backend;
}
/**
 * Creates a new SQLite worker thread, can accept an optional HTTP backend for HTTP support.
 *
 * The sync backend is particularly inefficient in Node.js and should never be used except for unit-testing browser
 * code.
 *
 * @param {SQLiteOptions} [options] Options object
 * @param {VFSHTTP.Backend | true} [options.http] Optional HTTP backend, either a shared one or a dedicated sync one
 * @returns {Promise<SQLite.Promiser>}
 */
export declare function createSQLiteThread(options?: SQLiteOptions): Promise<SQLite.Promiser>;
/**
 * Creates a new HTTP backend worker that can support multiple SQLite threads.
 * The cache is shared only if the environment supports SharedArrayBuffer.
 *
 * This is always the case in Node.js, but it requires a cross-origin isolated
 * environment in the browser.
 *
 * @param {VFSHTTP.Options} [options] Options object
 * @returns {VFSHTTP.Backend}
 */
export declare function createHttpBackend(options?: VFSHTTP.Options): VFSHTTP.Backend;
/**
 * Initialize synchronous SQLite in the current thread, can accept an optional HTTP backend for HTTP support.
 *
 * The sync backend is particularly inefficient in Node.js and should never be used except for unit-testing browser
 * code.
 *
 * @param {SQLiteOptions} [options] Options object
 * @param {VFSHTTP.Backend | true} [options.http] Optional HTTP backend, either a shared one or a dedicated sync one
 * @returns {Promise<SQLite.SQLite3>}
 */
export declare function initSyncSQLite(options?: SQLiteOptions): Promise<SQLite.SQLite3>;
export interface SQLiteHTTPPool {
    /**
     * Open a new remote database
     * @param {string} url Remote database
     * @returns {Promise<void>}
     */
    open(url: string): Promise<void>;
    /**
     * Dispose of the pool (stops the background workers)
     * @returns {Promise<void>}
     */
    close(): Promise<void>;
    /**
     * Run an SQL statement
     * @param {string} sql SQL statement
     * @param {Record<string, SQLite.SQLBindable> | SQLite.SQLBindable[]} [bind] Optional map of values to be bound
     * @param {Record<string, any>} [options] Options
     * @param {'array' | 'object'} [options.rowMode] SQLite row format, @default array
     * @returns {Promise<SQLite.Row[]>}
     */
    exec(sql: string, bind?: Record<string, SQLite.SQLBindable> | SQLite.SQLBindable[], opts?: {
        rowMode?: 'array';
    }): Promise<SQLite.RowArray[]>;
    exec(sql: string, bind: Record<string, SQLite.SQLBindable> | SQLite.SQLBindable[] | undefined, opts: {
        rowMode: 'object';
    }): Promise<SQLite.RowObject[]>;
    readonly backendType: VFSHTTP.Backend['type'];
}
/**
 * Higher-level API for working with a pool
 * @param {number} [opts.workers] Number of concurrent workers to spawn, @default 1
 * @param {VFSHTTP.Options} [opts.httpOptions] Options to pass to the HTTP backend
 */
export declare function createSQLiteHTTPPool(opts: {
    workers?: number;
    httpOptions?: VFSHTTP.Options;
}): Promise<SQLiteHTTPPool>;
